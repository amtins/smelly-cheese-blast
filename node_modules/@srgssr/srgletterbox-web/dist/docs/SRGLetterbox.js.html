<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: SRGLetterbox.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: SRGLetterbox.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import videojs from 'video.js';
import SRGLetterboxConfiguration from './utils/SRGLetterboxConfiguration.js';
import SRGUserStorage from './utils/SRGUserStorage.js';

import 'videojs-contrib-eme';
import 'videojs-contrib-dash';
import 'videojs-contrib-quality-levels';

import './mediaPlayer/middlewares/srgssr-middleware.js';
import './mediaPlayer/middlewares/videojs-mediacomposition-middleware.js';
import './mediaPlayer/components/button.js';
import './mediaPlayer/components/header-component.js';
import './mediaPlayer/components/picture-in-picture-toggle.js';
import './mediaPlayer/components/image-copyright.js';
import './mediaPlayer/components/play-toggle-component.js';
import './mediaPlayer/components/overlay-component.js';
import './mediaPlayer/components/current-time-display-component.js';
import './mediaPlayer/components/seek-to-live-component.js';
import './mediaPlayer/components/menu/srg-menu-close-button.js';
import './mediaPlayer/components/menu/srg-menu.js';
import './mediaPlayer/components/menu/srg-menu-button.js';
import './mediaPlayer/components/menu/settings/settings-menu.js';
import './mediaPlayer/components/menu/settings/settings-button.js';
import './mediaPlayer/components/menu/subtitles/subtitles-menu.js';
import './mediaPlayer/components/menu/subtitles/subtitles-button.js';
import './mediaPlayer/components/menu/playbackRate/playback-rate-menu.js';
import './mediaPlayer/components/menu/playbackRate/playback-rate-button.js';
import './mediaPlayer/components/chromecast-toggle-component.js';
import './mediaPlayer/components/SRGSSR-button-component.js';
import './mediaPlayer/components/endScreen/end-screen-component.js';
import './mediaPlayer/components/error-display-component.js';
import './mediaPlayer/components/time-tool-tip-component.js';
import './mediaPlayer/components/subdivisions/subdivisions-container.js';
import './mediaPlayer/components/warning-message-component.js';
import './mediaPlayer/components/airplay-button.js';
import './mediaPlayer/components/backward-button.js';
import './mediaPlayer/components/forward-button.js';
import './mediaPlayer/components/text-track-display.js';

import { version } from '../package.json';
import build from '../generated/build.json';

import * as videojsFRLanguage from './lang/fr-CH.json';
import * as videojsRMLanguage from './lang/rm-CH.json';
import * as videojsITLanguage from './lang/it-CH.json';
import * as videojsDELanguage from './lang/de-CH.json';
import * as videojsENLanguage from './lang/en-US.json';

import MediaComposition from './dataProvider/model/MediaComposition.js';
import SRGAnalytics from './analytics/SRGAnalytics.js';
import MediaStatistic from './analytics/MediaStatistic.js';
import Subdivision from './mediaPlayer/components/subdivisions/subdivision.js';
import * as SRGEvents from './utils/SRGEvents.js';
import Utils from './utils/Utils.js';
import * as PlayerEvents from './utils/PlayerEvents.js';
import * as VideojsEvents from './utils/VideojsEvents.js';
import * as Events from './utils/Events.js';
import SupportedDevices from './utils/SupportedDevices.js';
import SRGLetterboxComponents, {
  SRGLetterboxComponentsPath,
} from './utils/SRGLetterboxComponents.js';

import './mediaPlayer/utils/chromecastPlayer.js';
import SRGMenuStrategy from './mediaPlayer/utils/SRGMenuStrategy.js';

import './mediaPlayer/scss/imports.scss';
/* eslint max-len: ["error", { "ignoreComments": true }] */

/**
 * @class SRGLetterbox
 *
 * The SRGLetterbox class provides a simple way to create a web player
 */
class SRGLetterbox {
  /**
   * @constructor
   *
   * @param {Object} options parameter comes by default with predefined values that can be overridden at the instantiation time.
   *
   * See SRGLetterbox.LETTERBOX_DEFAULT_OPTIONS and its documentation for available options.
   */
  constructor(options = {}) {
    const defaultOptions = SRGLetterbox.LETTERBOX_DEFAULT_OPTIONS;
    //  TODO: handle configuration in a better way in PLAYRTS-1331
    const integrationOptions = {
      ...options,
      continuousPlayback: options.continuousPlayback !== undefined
        ? options.continuousPlayback : defaultOptions.continuousPlayback,
    };
    SRGUserStorage.setUserSettings(integrationOptions.defaultUserSettings);

    this.applyLetterboxOptions(integrationOptions);
    this.applyLetterboxOptions(SRGUserStorage.playbackSettings);
    this.applyLetterboxOptions(defaultOptions);

    this.playerOptions = Object.assign(
      {},
      SRGLetterboxConfiguration.defaultPlayerOptions(this),
      {
        chromeCastReceiver: this.chromeCastReceiver,
      },
    );

    videojs.addLanguage('fr', videojsFRLanguage);
    videojs.addLanguage('en', videojsENLanguage);
    videojs.addLanguage('it', videojsITLanguage);
    videojs.addLanguage('rm', videojsRMLanguage);
    videojs.addLanguage('de', videojsDELanguage);
  }

  /**
   * @ignore
   * @private
   */
  applyDebug() {
    const level = this.debug ? 'debug' : 'error';
    if (this.player) {
      this.player.log.level(level);
    }
    videojs.log.level(level);
    videojs.Html5DashJS.hook('beforeinitialize', (player, mediaPlayer) => {
      mediaPlayer.getDebug().setLogToBrowserConsole(false);
    });
  }

  /**
   * @ignore
   * @private
   */
  applyFillMode() {
    if (this.player) {
      if (this.fillMode) {
        this.player.fill(true);
      } else {
        this.player.fluid(true);
      }
    }
  }

  /**
   * @ignore
   * @private
   */
  applyFocus() {
    if (this.player
      &amp;&amp; this.playerFocus instanceof Object
      &amp;&amp; {}.hasOwnProperty
        .call(this.playerFocus, 'preventScroll')) {
      this.player.el().focus(this.playerFocus);
    }
  }

  /**
   * @ignore
   * @private
   */
  applyHdMode(hdMode) {
    if (this.hdMode !== hdMode) {
      this.hdMode = hdMode;

      this.prepareToPlayMediaComposition(
        this.getMediaComposition(),
        this.player.currentTime(),
        { forcePlay: true },
      );
    }
  }

  /**
   * @ignore
   * @private
   */
  applyContinuousPlayback(isFromUser = false) {
    const {
      continuousPlayback: userContinuousPlayback,
    } = SRGUserStorage.playbackSettings;
    let isUserChoice = false;

    // If the feature is activated and the user has set another choice, the option must be updated
    if (
      this.continuousPlayback
      &amp;&amp; userContinuousPlayback !== undefined
      &amp;&amp; this.continuousPlayback !== userContinuousPlayback
    ) {
      isUserChoice = true;
      this.continuousPlayback = userContinuousPlayback;
    }

    // If the change is an integrator choice we need to know it in order to update menus
    if (!isFromUser &amp;&amp; !isUserChoice) {
      this.player.trigger({
        type: Events.CONTINUOUS_PLAYBACK_INTEGRATION_CHANGE,
        data: this.continuousPlayback,
      });
    }
  }

  /**
   * @ignore
   * @private
   */
  applyIlHost() {
    if (this.ilHost) {
      this.playerOptions.SRGProviders.dataService.setIlHost(this.ilHost);
    }
  }

  /**
   * Apply letterbox options for each defined key if not already set.
   *
   * @ignore
   * @private
   */
  applyLetterboxOptions(options) {
    Object.keys(SRGLetterbox.LETTERBOX_DEFAULT_OPTIONS).forEach((key) => {
      const value = options[key];
      if (this[key] === undefined) {
        this[key] = value;
      }
    });
  }

  /**
   * Apply visibility to the components listed
   * @param {Object} components list of components from SRGLetterboxComponents
   * @ignore
   * @private
   */
  applyComponentsVisibility(components) {
    this.components = {};
    Object.keys(SRGLetterbox.srgLetterboxComponents).forEach((key) => {
      const value = components[key];
      if (value !== undefined) {
        this.setComponentVisibility(key, value);
      }
    });
  }

  /**
   * Sets the visibility of a visual component
   *
   * @param {string} [component]
   *        The component's name from SRGLetterboxComponents that we want to target
   * @param {boolean} [visibility]
   *        The visibility of the component (true=visible, false=invisible)
   *
  */
  setComponentVisibility(component, visibility) {
    const visualComponent = this.getVisualComponent(component);

    if (!visualComponent) return;

    this.components[component] = visibility;
    visualComponent.options({ isComponentVisible: visibility });

    if (visibility) {
      visualComponent.show();
    } else {
      visualComponent.hide();
    }
  }

  /**
   * Getter to access visual components of letterbox
   *
   * @param {string} [component]
   *        The component's name from SRGLetterboxComponents that we want to target
   *
   * @return {node|undefined}
   *         - The visual component instance
   *         - undefined when the path is wrong
  */
  getVisualComponent(component) {
    const componentPath = SRGLetterboxComponentsPath[component];

    if (!componentPath) return undefined;

    // TODO: Use getDescendant when videojs version will be >= 7.8
    return componentPath.reduce((item, nextItem) => {
      if (!item || !item.getChild) return undefined;

      return item.getChild(nextItem);
    }, this.player);
  }

  /**
   * A getter/setter for the `Player`'s aspect ratio.
   *
   * @param {string} [ratio]
   *        The value to set the Player's aspect ratio to.
   *
   * @see fill
   * @see https://docs.videojs.com/player#aspectRatio
   * @see https://docs.videojs.com/tutorial-layout.html
   *
   * @return {string|undefined}
   *         - The current aspect ratio of the `Player` when getting.
   *         - undefined when setting
  */
  aspectRatio(ratio) {
    return this.player.aspectRatio(ratio);
  }

  /**
   * Get or set the autoplay option.
   * - true: autoplay using the browser behavior
   * - false: do not autoplay
   * - 'play': call play() on every loadstart
   * - 'muted': call muted() then play() on every loadstart
   * - 'any': call play() on every loadstart. if that fails call muted() then play().
   * - *: values other than those listed here will be set `autoplay` to true
   *
   * @param {boolean|string} value
   *
   * @see https://docs.videojs.com/player#autoplay
   */
  autoplay(value) {
    if (value !== undefined || SRGUserStorage.autoplay === undefined) {
      SRGUserStorage.store(
        SRGUserStorage.storageKey.autoplay,
        !!value,
      );

      this.player.trigger(Events.AUTOPLAY_CHANGE);
    }

    return this.player.autoplay(value);
  }

  /**
   * Get or set the subtitles language
   * The value should be the language code of the text track
   * @param {string} value
   */
  subtitlesLanguage(value) {
    const tracks = Array.from(this.player.textTracks())
      .filter(track => track.kind !== 'metadata');

    if (value !== undefined) {
      tracks.forEach((track) => {
        const textTrack = track;

        textTrack.mode = textTrack.language === value ? 'showing' : 'hidden';
      });

      return value;
    }

    const currentTrack = tracks.find(track => track.mode === 'showing');

    return currentTrack &amp;&amp; currentTrack.language;
  }

  /**
   * Get or set the text track font size.
   *
   * @param {Number} fontSize is a size level between 1 and 8.
   * @returns {Number|undefined} The font size in percent.
   */
  subtitlesSize(fontSize) {
    const { player } = this;
    const textTrackDisplay = player.getChild('textTrackDisplay');

    if (textTrackDisplay &amp;&amp; fontSize) {
      textTrackDisplay.setFontSize(fontSize);
    }

    return textTrackDisplay
      &amp;&amp; textTrackDisplay.fontSize;
  }

  /**
   * Get or set the audio track language
   * The value should be the id code of the audio track
   * @param {string} value
   */
  audioLanguage(value) {
    const audioTracks = Array.from(this.player.audioTracks());

    if (value !== undefined) {
      audioTracks.forEach((track) => {
        // eslint-disable-next-line no-param-reassign
        track.enabled = track.id === value;
      });
      return value;
    }
    const currentTrack = audioTracks.find(track => track.enabled);
    return currentTrack &amp;&amp; currentTrack.id;
  }

  /**
   * Get or set the current time (in seconds)
   *
   * @param {number|string} [seconds] The time to seek to in seconds
   *
   * @return {number} The current time in seconds when getting
   */
  currentTime(seconds) {
    return this.player.currentTime(seconds);
  }

  /**
   * Destroys the video player and does any necessary cleanup.
   * This is especially helpful if you are dynamically adding and removing videos to/from the DOM.
   *
   * @see https://docs.videojs.com/player#dispose
   *
   * @fires videojs#event:dispose
   */
  dispose() {
    this.player.dispose();
  }

  /**
   * Return letterbox duration of the currently playing stream. This is videojs duration
   * ( @see https://docs.videojs.com/player#paused ) when the player is initialized,
   * or the mediacomposition duration if the player is not yet playing.
   *
   * @returns {number | undefined} duration in seconds
   */
  duration() {
    const playerDuration = this.player.duration();
    if (playerDuration) {
      return playerDuration;
    }
    const mediaComposition = this.getMediaComposition();
    if (mediaComposition) {
      const mainChapter = mediaComposition.getMainChapter();
      return Utils.millisecondsToSeconds(mainChapter.duration);
    }
    return undefined;
  }

  /**
   * Get the value of the `error` from the media element.
   * `error` indicates any MediaError that may have occurred during playback.
   * If error returns null there is no current error.
   *
   * __FYI__: video.js error method allows a `MediaError` object as a parameter, Letterbox don't.
   *
   * @returns MediaError | null
   *
   * @see https://docs.videojs.com/html5#error
   */
  error() {
    return this.player.error();
  }

  /**
   * A getter/setter/toggler for the vjs-fill `className` on the `Player`.
   *
   * Turning this on will turn off fluid mode.
   *
   * By default Letterbox uses the fill mode.
   * This means the player will take all the available space in his container.
   *
   * @see https://docs.videojs.com/player#fill
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will be a getter.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */
  fill(bool) {
    return this.player.fill(bool);
  }

  /**
   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.
   *
   * Turning this on will turn off fill mode.
   *
   * @see https://docs.videojs.com/player#fluid
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will be a getter.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */
  fluid(bool) {
    return this.player.fluid(bool);
  }

  /**
   * Get the currently playing Media Composition.
   *
   * @returns {MediaComposition}
   */
  getMediaComposition() {
    return this.player.options().SRGProviders.mediaComposition;
  }

  /**
   * Get the current playback settings.
   *
   * @returns {Object}
   */
  getPlaybackSettings() {
    return this.player.currentSource().playbackSettings;
  }

  /**
   * @returns {String} currently playing URN
   */
  getUrn() {
    const mediaComposition = this.getMediaComposition();
    return mediaComposition
      &amp;&amp; (mediaComposition.segmentUrn || mediaComposition.chapterUrn);
  }

  /**
   * Check if the MediaComposition has subdivisions.
   *
   * @returns {Boolean}
   */
  hasSubdivisions() {
    const mediaComposition = this.getMediaComposition();
    return mediaComposition
      ? mediaComposition.getSubdivisions().length > 0 : false;
  }

  /**
   * Connect this instance to a given element and initialize videojs player.
   *
   * The current configuration (see setXXX methods) is applied to this player.
   *
   * @param containerElement DOM element to attach this player to (id string, class string or a DOM element). If this is a string and not an id or string, a new div element is created
   * @returns {Node} DOM Element the player has been attached to
   */
  initializeOnElement(containerElement) {
    let element;

    if (typeof containerElement === 'string') {
      element = document.querySelector(
        `#${containerElement}, .${containerElement}`,
      );
    } else {
      element = containerElement;
    }

    if (!element) {
      throw new Error(`${containerElement} not found`);
    }

    const video = SRGLetterbox.defaultVideo();

    if (videojs.browser.IS_IPHONE) {
      video.setAttribute('playsinline', '');
    }

    this.video = video;

    element.classList.add('letterbox-web');
    element.appendChild(video);

    if (this.language) {
      this.playerOptions.language = this.language;
    }

    // eslint-disable-next-line new-cap
    this.player = new videojs(video, this.playerOptions);
    this.player.version = SRGLetterbox.VERSION;

    this.applyIlHost();
    this.applyDebug();
    this.applyFocus();
    this.applyFillMode();
    this.applyContinuousPlayback();
    this.SRGMenuStrategy = new SRGMenuStrategy(this);

    if (this.components) {
      this.applyComponentsVisibility(this.components);
    }

    this.srgStorage = new SRGUserStorage(this.player);
    this.statistics = new SRGAnalytics(
      this.player,
      SRGLetterbox.VERSION,
      this.debug,
    );
    this.mediaStatistic = new MediaStatistic(
      this.player,
      this.ilHost,
      this.debug,
    );

    return element;
  }

  /**
   * @see setHdMode
   * @returns {Boolean} true when in HD Mode
   */
  isHdMode() {
    return this.hdMode;
  }

  /**
   * @see setContinuousPlayback
   * @returns {Boolean} true when continuous playback is enabled
   */
  isContinuousPlaybackEnabled() {
    return this.continuousPlayback;
  }

  /**
   * @see setRecommendations
   * @returns {Boolean} true when recommendations are enabled
   */
  areRecommendationsEnabled() {
    return this.recommendations;
  }

  /**
   * Get the current muted state, or turn mute on or off
   *
   * @see https://docs.videojs.com/player#muted
   *
   * @param {boolean} [muted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean}
   *         - true if mute is on and getting
   *         - false if mute is off and getting
   */
  muted(muted) {
    return this.player.muted(muted);
  }

  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   *
   * @see https://github.com/videojs/video.js/blob/v7.7.4/src/js/mixins/evented.js#L337
   */
  off(elem, typeopt, fnopt) {
    this.player.off(elem, typeopt, fnopt);
  }

  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   *
   * @see https://github.com/videojs/video.js/blob/v7.7.4/src/js/mixins/evented.js#L192
   */
  on(...args) {
    this.player.on(...args);
  }

  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will be called once per event and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   *
   * @see https://github.com/videojs/video.js/blob/v7.7.4/src/js/mixins/evented.js#L244
   */
  one(...args) {
    this.player.one(...args);
  }

  /**
   * Pause the video playback.
   *
   * @see https://docs.videojs.com/player#pause
   */
  pause() {
    this.player.pause();
  }

  /**
   * Check if the player is paused.
   *
   * @see https://docs.videojs.com/player#paused
   *
   * @returns {Boolean}
   */
  paused() {
    return this.player.paused();
  }

  /**
   * Attempt to begin playback.
   *
   * @see https://docs.videojs.com/player#play
   *
   * @return {Promise|undefined}
   */
  play() {
    return this.player.play();
  }

  /**
   * Gets or sets the current playback rate. A playback rate of 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.
   *
   * @param {Number} rateopt New playback rate to set.
   *
   * @see https://docs.videojs.com/player#playbackRate
   *
   * @returns {Number} The current playback rate when getting or 1.0
   */
  playbackRate(rateopt) {
    return this.player.playbackRate(rateopt);
  }

  /**
   * @ignore
   * @private
   * @fires Events.PREPARE_TO_PLAY
   */
  prepareToPlay(
    urn,
    mediaComposition,
    pendingSeek,
    playbackSettings = {},
    autoplay,
    standalone = false,
  ) {
    if (!this.video) {
      throw new Error('You must call initializeOnElement first');
    }

    const evt = {
      type: Events.PREPARE_TO_PLAY,
      data: {
        ready: false,
      },
    };

    this.trigger(evt);

    this.player.loadMedia({
      src: {
        type: 'srgssr/urn',
        src: urn,
        mediaComposition,
        pendingSeek,
        playbackSettings,
        standalone,
      },
    }, () => {
      evt.data.ready = true;

      this.trigger(evt);

      if (playbackSettings.forcePlay) {
        this.player.play();
      } else {
        this.autoplay(autoplay);
      }

      if (SupportedDevices.isTouchDevice) {
        this.player.addClass('srgssr-touch-enabled');
      } else {
        this.player.removeClass('srgssr-touch-enabled');
      }
    });
  }

  /**
   * Load a media provided as a mediacomposition.
   *
   * @param {Object} mediaComposition data or mediaComposition object
   * @param {Number} pendingSeek position to play at in seconds or undefined to play at stream default position
   * @param {Object} playbackSettings options to be stored with the playback context,
   *                 can be used for application specific information
   *                 they can be read back in getPlaybackSettings
   * @param {boolean|string} autoplay value
   *
   * @see prepareToPlayURN
   * @see autoplay autoplay value
   * @see getPlaybackSettings
   * @see getMediaComposition
   */
  prepareToPlayMediaComposition(
    mediaComposition,
    pendingSeek,
    playbackSettings,
    autoplay,
  ) {
    this.prepareToPlay(
      mediaComposition.segmentUrn || mediaComposition.chapterUrn,
      MediaComposition.cleanCache(mediaComposition),
      pendingSeek,
      playbackSettings,
      autoplay,
    );
  }

  /**
   * Load an URN.
   *
   * @param {String} urn string
   * @param {Number} pendingSeek position to play at in seconds or undefined to play at stream default position
   * @param {Object} playbackSettings options to be stored with the playback context,
   *                 can be used for application specific information
   *                 they can be read back in getPlaybackSettings
   * @param {boolean|string} autoplay value
   * @param {bolean} standalone allow to switch between onlyChapters true/false.
   *                 The default value is false.
   *
   * @see autoplay autoplay value
   * @see getPlaybackSettings
   * @see getMediaComposition
   */
  prepareToPlayURN(
    urn,
    pendingSeek = undefined,
    playbackSettings = undefined,
    autoplay = undefined,
    standalone = false,
  ) {
    this.prepareToPlay(
      urn,
      undefined,
      pendingSeek,
      playbackSettings,
      autoplay,
      standalone,
    );
  }

  /**
   * Restart playback from URN.
   *
   * @param autoplay autoplay property
   *
   * @see autoplay
   */
  restart(autoplay = true) {
    this.prepareToPlayURN(this.getUrn(), undefined, undefined, autoplay);
  }

  /**
   * Set debug mode. Can be called before or after #initializeOnElement
   *
   * @param {Boolean} debug mode
   */
  setDebug(debug) {
    this.debug = debug;
    this.applyDebug(debug);

    return this;
  }

  /**
   * Change player integration mode.
   *
   * @param {Boolean} fillMode true for fill mode, false will revert back to default (fluid)
   */
  setFillMode(fillMode) {
    this.fillMode = fillMode;
    this.applyFillMode();

    return this;
  }

  /**
   * Configure Letterbox HD Mode. This selects HD quality playlist in the mediacomposition.
   * Switching mid-stream will stop the player and change the currently playing resource and
   * resume playback at the appropriate position.
   *
   * @param {Boolean} hdMode false to disallow playback of HD quality playlist if an SD is available.
   */
  setHdMode(hdMode) {
    this.applyHdMode(hdMode);

    SRGUserStorage.store(SRGUserStorage.storageKey.hdMode, hdMode);
  }

  /**
   * Set IL Host. Can be called before or after #initializeOnElement .
   *
   * @param {String} hostName IL Host to use for mediacomposition requests (integration layer)
   */
  setIlHost(hostName) {
    this.ilHost = hostName;
    this.applyIlHost();

    return this;
  }

  /**
   * Set the player language. If not called, the player will select a language automatically based
   * on videojs rules.
   * @see https://docs.videojs.com/docs/guides/languages.html#setting-default-language-in-a-video-js-player
   *
   * This method cannot be called after player initialization as changing videojs localizations are
   * not updated.
   *
   * @param {String} lang language code name ISO-639-1
   * @returns {SRGLetterbox}
   */
  setLanguage(lang) {
    if (this.player) {
      throw new Error('Cannot be called after player initialization');
    }

    this.language = lang;

    return this;
  }

  /**
   * Focus the player to handle hot keys event.
   *
   * The focus will be applied immediately if called after
   * initializeOnElement or during initializeOnElement if called before.
   *
   * @param {Object} focus
   * @param {Boolean} focus.preventScroll
   *
   * @example
   * setPlayerFocus(false)
   * setPlayerFocus(undefined)
   * setPlayerFocus(null)
   * setPlayerFocus({preventScroll: false})
   *
   * @returns {SRGLetterbox}
   */
  setPlayerFocus(focus) {
    this.playerFocus = focus;
    this.applyFocus();

    return this;
  }

  /**
   * Set continuous playback mode
   *
   * @param {Boolean} continuousPlayback allows to play another content after the content currently played is over
   *          with false the continuous playback will be disabled and the recommendation grid will be displayed
   *          with true the continuous playback will be enabled
   * @param {Boolean} isFromUser set to true when the value change is a user action
   */
  setContinuousPlayback(continuousPlayback, isFromUser = false) {
    this.continuousPlayback = continuousPlayback;

    if (isFromUser) {
      SRGUserStorage.store(
        SRGUserStorage.storageKey.continuousPlayback,
        continuousPlayback,
      );
    }

    this.player.trigger(Events.CONTINUOUS_PLAYBACK_CHANGE);
    this.applyContinuousPlayback(isFromUser);

    return this;
  }

  /**
   * Set recommendations mode
   *
   * @param {Boolean} recommendations, allows to show recommendations at the end screen
   *          with false the replay screen will be shown
   *          with true the recommendations grid will be shown
   */
  setRecommendations(recommendations) {
    this.recommendations = recommendations;

    return this;
  }

  /**
   * Switch URN. Play a different URN in the same context.
   *
   * - Switch to segment if urn is within segment list of the current mediacomposition
   * (e.g.: full DVR highlight or live). Will start at the beginning of the segment,
   * or at the edge of live for live.
   * - Switch to chapter if urn is within chapter list of the current mediacomposition
   * (e.g.: limited DVR highlight or live). Will start at the beginning of the segment,
   * or at the edge of live for live.
   *
   * This will start playing if player is not currently playing.
   *
   * @param {String} urn to play
   */
  switchToUrn(urn) {
    const mediaComposition = this.getMediaComposition();
    const [segment] = mediaComposition
      .getMainSegments()
      .filter(s => s.urn === urn);

    if (segment) {
      Subdivision.seekToSegment(this.player, segment);
      this.player.play();
    } else {
      this.prepareToPlayURN(urn, undefined, undefined, true);
    }
  }

  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @return {boolean}
   *          Whether or not the default behavior was prevented.
   *
   * @see https://github.com/videojs/video.js/blob/v7.7.4/src/js/mixins/evented.js#L389
   */
  trigger(event, hash) {
    this.player.trigger(event, hash);
  }

  /**
   * Get or set the current volume of the media
   *
   * @see https://docs.videojs.com/player#volume
   *
   * @param  {number} [percentAsDecimal]
   *         The new volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number}
   *         The current volume as a percent when getting
   */
  volume(percentAsDecimal) {
    return this.player.volume(percentAsDecimal);
  }

  /**
   * Object with detailed build information.
   */
  static get BUILD() {
    return build;
  }

  /**
   * Represents the default video element filled with some default video.js CSS classes.
   *
   * @returns {HTMLVideoElement} HTML video element
   */
  static defaultVideo() {
    const video = document.createElement('video');

    // TODO Remove the unused classes
    video.classList.add('video-js');
    video.classList.add('vjs-srgssr-skin');
    // video.classList.add('vjs-fill');
    // video.classList.add('vjs-16-9');
    video.classList.add('vjs-fluid');
    video.classList.add('vjs-show-big-play-button-on-pause');

    video.setAttribute('crossorigin', 'anonymous');

    return video;
  }

  /**
   * Aggregates all available event properties
   *
   * @type {Object}
   *
   * @event SRGLetterbox#events
   *
   * @linkcode SRGLetterbox#playerEvents
   * @linkcode SRGLetterbox#srgEvents
   * @linkcode SRGLetterbox#videojsEvents
   */
  static get events() {
    return Events;
  }

  /**
   * Letterbox options. Those options can be overridden in the constructor
   *
   * @param {Boolean} debug, debug mode to show logs in dev console through videojs logs
   * @param {String} ilHost, Integration layer server hostname to use for URN resolution
   * @param {Boolean} fillMode, set the layout: (true for fill, false for fluid)
   * @param {Object} playerFocus, set the focus to the player at initialization to use hotkeys
   * @param {String} language, language for all strings (support for EN, FR, DE, IT and RM only)
   * @param {Boolean} hdMode, true: force HD quality, false: force SD
   * @param {Boolean} continuousPlayback, allows to play another content after the content currently played is over
   *          with false the continuous playback will be disabled and the recommendation grid will be displayed if activated
   *          with true the continuous playback will be enabled if the user did not disabled the feature
   * @param {Boolean} recommendations, allows to show recommendations at the end screen
   *          with false the replay screen will be shown
   *          with true the recommendations grid will be shown
   * @param {Object} components, allows to show or hide a list of components.
   *          If a component is not in the list, its visibility is the one set by default in the component
   *            each key is the component from SRGLetterboxComponents
   *            each value represents the visibility with true=visible and false=hidden
   *            See SRGLetterboxComponents for a list of default components
   * @param {String} chromeCastReceiver, set a custom Chrome Cast Receiver app id.
   *
   * Note that setting hdMode to true or false will not affect UI availability. Meaning that the user
   * will still able to toggle HD mode for this session.
   *
   */
  static get LETTERBOX_DEFAULT_OPTIONS() {
    return {
      debug: false,
      ilHost: 'il.srgssr.ch',
      fillMode: true,
      playerFocus: undefined,
      language: undefined,
      hdMode: undefined,
      continuousPlayback: true,
      recommendations: true,
      components: {},
      chromeCastReceiver: '1AC2931D',
    };
  }

  /**
   * Long string with detailed version and build information.
   * @returns {string} displayable string
   */
  static get LONG_VERSION() {
    const date = new Date(parseInt(build.date, 10));
    // eslint-disable-next-line max-len
    return `${version} built at ${date} from ${build.commit} using ${build.runner} by ${build.initiator}`;
  }

  /**
   * @returns {MediaComposition} MediaComposition class
   * @constructor
   */
  static get MediaComposition() {
    return MediaComposition;
  }

  /**
   * Standard player events.
   *
   * @see https://developer.mozilla.org/fr/docs/Web/Guide/DOM/Events/evenement_medias
   * @event  SRGLetterbox#playerEvents
   */
  static get playerEvents() {
    return PlayerEvents;
  }

  /**
   * SRG events.
   *
   * @type {Object}
   * @event  SRGLetterbox#srgEvents
   */
  static get srgEvents() {
    return SRGEvents;
  }

  /**
   * SupportedDevices allows to detect browser's version
   * and some features compatibilities.
   *
   * @returns {supportedDevices} supportedDevices class
   */
  static get supportedDevices() {
    return SupportedDevices;
  }

  /**
   * Represents the Letterbox version.
   *
   * @returns {String}
   */
  static get VERSION() {
    return version;
  }

  /**
   * Video.js events.
   *
   * FYI: Not all Video.js are exposed.
   *
   * @type {Object}
   * @event  SRGLetterbox#videojsEvents
   */
  static get videojsEvents() {
    return VideojsEvents;
  }

  /**
   * @returns {SRGLetterboxComponents} Components list
   */
  static get srgLetterboxComponents() {
    return SRGLetterboxComponents;
  }
}

export default SRGLetterbox;

window.videojs = videojs;
window.SRGLetterbox = SRGLetterbox;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="SRGLetterbox.html">SRGLetterbox</a></li><li><a href="SRGLetterbox.MediaComposition.html">MediaComposition</a></li><li><a href="SRGUserStorage.html">SRGUserStorage</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:ADD_TRACK">ADD_TRACK</a></li><li><a href="global.html#event:ANIMATION_END">ANIMATION_END</a></li><li><a href="global.html#event:BEFOREUNLOAD">BEFOREUNLOAD</a></li><li><a href="global.html#event:CHANGE">CHANGE</a></li><li><a href="global.html#event:CLICK">CLICK</a></li><li><a href="global.html#event:KEY_DOWN">KEY_DOWN</a></li><li><a href="global.html#event:MOUSE_ENTER">MOUSE_ENTER</a></li><li><a href="global.html#event:srgssr/recommendationDisplayed">srgssr/recommendationDisplayed</a></li><li><a href="global.html#event:srgssr/recommendationHit">srgssr/recommendationHit</a></li><li><a href="global.html#event:WEBKIT_CURRENT_PLAYBACK_TARGET_IS_WIRELESS_CHANGED">WEBKIT_CURRENT_PLAYBACK_TARGET_IS_WIRELESS_CHANGED</a></li><li><a href="global.html#event:WEBKIT_PLAYBACK_TARGET_AVAILABILITY_CHANGED">WEBKIT_PLAYBACK_TARGET_AVAILABILITY_CHANGED</a></li><li><a href="SRGLetterbox.html#event:events">events</a></li><li><a href="SRGLetterbox.html#event:playerEvents">playerEvents</a></li><li><a href="SRGLetterbox.html#event:srgEvents">srgEvents</a></li><li><a href="SRGLetterbox.html#event:videojsEvents">videojsEvents</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ABORT">ABORT</a></li><li><a href="global.html#ALMOST_STARTING">ALMOST_STARTING</a></li><li><a href="global.html#containQualities">containQualities</a></li><li><a href="global.html#DISPOSE">DISPOSE</a></li><li><a href="global.html#filterMainResourcesByQuality">filterMainResourcesByQuality</a></li><li><a href="global.html#findChapterByUrn">findChapterByUrn</a></li><li><a href="global.html#findDrmListByResource">findDrmListByResource</a></li><li><a href="global.html#findMainSegment">findMainSegment</a></li><li><a href="global.html#findResourceListByUrn">findResourceListByUrn</a></li><li><a href="global.html#getChapters">getChapters</a></li><li><a href="global.html#getFilteredExternalSubtitles">getFilteredExternalSubtitles</a></li><li><a href="global.html#getMainBlockReason">getMainBlockReason</a></li><li><a href="global.html#getMainChapter">getMainChapter</a></li><li><a href="global.html#getMainChapterImageUrl">getMainChapterImageUrl</a></li><li><a href="global.html#getMainResources">getMainResources</a></li><li><a href="global.html#getMainSegments">getMainSegments</a></li><li><a href="global.html#getMainValidFromDate">getMainValidFromDate</a></li><li><a href="global.html#getMergedAnalyticsData">getMergedAnalyticsData</a></li><li><a href="global.html#getMergedAnalyticsMetadata">getMergedAnalyticsMetadata</a></li><li><a href="global.html#getResourceList">getResourceList</a></li><li><a href="global.html#getSubdivisions">getSubdivisions</a></li><li><a href="global.html#isSourceHD">isSourceHD</a></li><li><a href="global.html#MAX_ITEMS">MAX_ITEMS</a></li><li><a href="global.html#MAX_ROWS">MAX_ROWS</a></li><li><a href="global.html#MIN_HEIGHT">MIN_HEIGHT</a></li><li><a href="global.html#MIN_WIDTH">MIN_WIDTH</a></li><li><a href="global.html#orderMainResourcesByQuality">orderMainResourcesByQuality</a></li><li><a href="global.html#orderMainResourcesByStreamType">orderMainResourcesByStreamType</a></li><li><a href="global.html#PERCENTAGE_MEDIA_CONSUMED">PERCENTAGE_MEDIA_CONSUMED</a></li><li><a href="global.html#PERIOD">PERIOD</a></li><li><a href="global.html#prefix">prefix</a></li><li><a href="global.html#SOON_VALID_PERIOD">SOON_VALID_PERIOD</a></li><li><a href="global.html#TOLERANCE">TOLERANCE</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Fri Feb 12 2021 09:53:42 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
