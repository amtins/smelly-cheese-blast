<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/SRGUserStorage.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/SRGUserStorage.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import LocalStorage from './LocalStorage.js';
import * as Events from './Events.js';
import SRGStreamType from './SRGStreamType.js';


/**
 * @class SRGUserStorage
 * @ignore
 *
 * The SRGUserStorage class provides a simple way to manipulate the user's local storage.
 */
class SRGUserStorage {
  /**
   * @constructor
   *
   * @param {Object} player
   */
  constructor(player) {
    this.player = player;

    this.initListeners();
  }

  /**
   * Listens to the loaded meta data event to set the audio track from local storage.
   *
   * @listens Events.LOADED_METADATA
   *
   */
  selectAudioTrack() {
    const { playbackSettings: { audioTrack: userAudioTrack } } = SRGUserStorage;
    if (!userAudioTrack) {
      return;
    }
    const [language, kind] = userAudioTrack.split('#');

    const tracks = Array.from(this.player.audioTracks())
      .filter(track => track.language === language);

    if (tracks.length > 0) {
      let target;
      const trackKind = tracks.filter(track => track.kind === kind);

      if (trackKind.length > 0) {
        target = trackKind.shift();
      } else {
        target = tracks.shift();
      }

      this.player.options()
        .SRGProviders
        .letterbox
        .audioLanguage(target.id);
    }
  }

  /**
   * Listens to the text track add event to set the text track from local storage.
   *
   * @listens Events.ADD_TRACK
   *
   * @param {*} trackObject
   */
  addTextTrack(trackObject) {
    const { kind, mode, playbackSettings } = SRGUserStorage;
    const { track } = trackObject;

    if (track.kind === kind.metadata || !this.player) {
      return;
    }

    if (playbackSettings.textTrack
      &amp;&amp; playbackSettings.textTrack === track.language) {
      // TODO remove setTimeout once SFR cues not available on addTextTrack is fixed
      setTimeout(() => {
        track.mode = mode.showing;
      }, 0);
    } else {
      track.mode = mode.hidden;
    }
  }

  /**
   * Listens to the audio track change event to get or set the audio tracks.
   *
   * @listens Events.CHANGE
   */
  audioTrackChange() {
    const { storageKey } = SRGUserStorage;
    const { tracks_: tracks } = this.player.audioTracks();
    const track = tracks
      .find(audioTrack => audioTrack.enabled);
    const languagetoStore = track ? `${track.language}#${track.kind}` : null;

    SRGUserStorage.store(storageKey.audioTrack, languagetoStore);
  }

  /**
   * Initialize all listeners used to store or retrieve the user's locale storage.
   *
   * __Used events__
   * - addtrack
   * - canplay
   * - change
   * - prepareToPlay
   * - volumechange
   */
  initListeners() {
    this.player.on([
      Events.CAN_PLAY,
      Events.PREPARE_TO_PLAY,
    ], this.prepareToPlay.bind(this));

    this.player.audioTracks().on(Events.CHANGE, this.audioTrackChange.bind(this));

    this.player.textTracks().on(Events.ADD_TRACK, this.addTextTrack.bind(this));
    this.player.textTracks().on(Events.CHANGE, this.textTrackChange.bind(this));

    this.player.on(Events.RATE_CHANGE, this.rateChange.bind(this));
    this.player.on(Events.TEXT_TRACK_SIZE_CHANGE, this.textTrackSizeChange.bind(this));
    this.player.on(Events.VOLUME_CHANGE, this.volumeChange.bind(this));
    this.player.on(Events.LOADED_METADATA, this.selectAudioTrack.bind(this));
  }

  /**
   * Listens to the can play and prepare to play events.
   *
   * @listens Events.CAN_PLAY
   * @listens Events.PREPARE_TO_PLAY
   *
   * @param {Object} event
   */
  prepareToPlay(event) {
    const { playbackSettings } = SRGUserStorage;
    const { type } = event;

    if (type === Events.PREPARE_TO_PLAY &amp;&amp; !event.data.ready) {
      this.mediaReady = false;
      this.canplay = false;
    }

    if (type === Events.PREPARE_TO_PLAY &amp;&amp; event.data.ready) {
      this.mediaReady = true;

      this.player.muted(playbackSettings.muted);
      this.player.volume(playbackSettings.volume);
      this.player.options()
        .SRGProviders
        .letterbox
        .subtitlesSize(playbackSettings.textTrackSize);
    }

    if (type === Events.CAN_PLAY) {
      this.canplay = true;
    }
  }

  /**
   * Store key value in user's locale storage.
   *
   * @static
   *
   * @param {String} key
   * @param {*} value
   */
  static store(key, value) {
    LocalStorage.store(SRGUserStorage.USER_STORAGE, key, value);
  }

  /**
   * Listens to the rate change event to get or set the playback rate.
   *
   * @listens Events.RATE_CHANGE
   */
  rateChange() {
    const { playbackSettings, storageKey } = SRGUserStorage;

    // Ensures that we're not between two states that happens when loading a new media.
    // RateChange is fired before loading a new media, that means hasStarted is true.
    if (this.canplay &amp;&amp; this.mediaReady &amp;&amp; this.player.hasStarted()) {
      SRGUserStorage.store(storageKey.playbackRate, this.player.playbackRate());
    } else {
      // We have to wait until the metadata is loaded
      // because ratechange event is fired before videojs knows
      // if we're trying to play a live stream or a VOD
      this.player.one(Events.LOADED_METADATA, () => {
        if (SRGStreamType.isOnDemand(this.player.currentSource().streamType)
          &amp;&amp; this.player.options().playbackRates.includes(playbackSettings.playbackRate)) {
          this.player.playbackRate(playbackSettings.playbackRate);
        } else {
          SRGUserStorage.store(storageKey.playbackRate, undefined);
        }
      });
    }
  }

  /**
   * Listens to the text track change event to get or set the text tracks.
   *
   * @listens Events.CHANGE
   */
  textTrackChange() {
    const {
      kind, mode, playbackSettings, storageKey,
    } = SRGUserStorage;
    const tracks = Array.from(this.player.textTracks());
    const metaDataFilter = textTrack => textTrack.kind !== kind.metadata;

    // Avoid enforced text tracks
    if (!this.canplay || !this.mediaReady) {
      tracks
        .filter(metaDataFilter)
        .forEach((textTrack) => {
          const track = textTrack;

          if (track.language === playbackSettings.textTrack) {
            track.mode = mode.showing;
          } else {
            track.mode = mode.hidden;
          }
        });
    } else if (this.player.hasStarted()) {
      const track = tracks
        .filter(metaDataFilter)
        .find(textTrack => textTrack.mode === mode.showing);
      const languagetoStore = track ? track.language : null;

      SRGUserStorage.store(storageKey.textTrack, languagetoStore);
    }
  }

  /**
   * Listens to the font size change event to get the font size in percent.
   *
   * @param {String} data - The font size in percent.
   */
  // eslint-disable-next-line class-methods-use-this
  textTrackSizeChange({ data }) {
    SRGUserStorage.store(SRGUserStorage.storageKey.textTrackSize, data);
  }

  /**
   * Listens to the volume change event to get or set the volume or muted property.
   *
   * __FYI__: Keep in mind videojs `loadMedia` calls a reset method
   * that triggers a volumechange event before loading the next media.
   *
   * @see [videojs loadMedia](https://github.com/videojs/video.js/blob/master/src/js/player.js#L4443)
   *
   * @listens PlayerEvents.VOLUME_CHANGE
   */
  volumeChange() {
    const { playbackSettings, storageKey } = SRGUserStorage;
    if (!this.mediaReady) {
      this.player.muted(playbackSettings.muted);
      this.player.volume(playbackSettings.volume);

      return;
    }

    SRGUserStorage.store(storageKey.muted, this.player.muted());
    SRGUserStorage.store(storageKey.volume, this.player.volume());
  }

  /**
   * Get text track kind.
   *
   * @static
   *
   * @returns { Object }
   */
  static get kind() {
    return {
      metadata: 'metadata',
    };
  }

  /**
   * Get the visibility mode for audio and text tracks.
   *
   * @static
   *
   * @returns { Object }
   */
  static get mode() {
    return {
      showing: 'showing',
      hidden: 'hidden',
    };
  }

  /**
   * Get playback settings from userStorage.
   *
   * @static
   *
   * @returns { Object }
   */
  static get playbackSettings() {
    const { USER_STORAGE } = SRGUserStorage;

    return LocalStorage.getStorageByName(
      USER_STORAGE, SRGUserStorage.defaultUserSettings,
    );
  }

  /**
   * Set playback settings from userStorage.
   *
   * @static
   *
   * @returns { Object }
   */
  static setUserSettings({ hdMode = true, ...settings } = {}) {
    SRGUserStorage.defaultUserSettings = { hdMode, ...settings };
  }

  /**
   * Get storage key.
   *
   * @static
   *
   * @returns { Object }
   */
  static get storageKey() {
    return {
      audioTrack: 'audioTrack',
      autoplay: 'autoplay',
      continuousPlayback: 'continuousPlayback',
      hdMode: 'hdMode',
      muted: 'muted',
      playbackRate: 'playbackRate',
      textTrack: 'textTrack',
      textTrackSize: 'textTrackSize',
      volume: 'volume',
    };
  }

  static get USER_STORAGE() { return 'srgssr/letterbox/userStorage'; }
}


export default SRGUserStorage;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="SRGLetterbox.html">SRGLetterbox</a></li><li><a href="SRGLetterbox.MediaComposition.html">MediaComposition</a></li><li><a href="SRGUserStorage.html">SRGUserStorage</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:ADD_TRACK">ADD_TRACK</a></li><li><a href="global.html#event:ANIMATION_END">ANIMATION_END</a></li><li><a href="global.html#event:BEFOREUNLOAD">BEFOREUNLOAD</a></li><li><a href="global.html#event:CHANGE">CHANGE</a></li><li><a href="global.html#event:CLICK">CLICK</a></li><li><a href="global.html#event:KEY_DOWN">KEY_DOWN</a></li><li><a href="global.html#event:MOUSE_ENTER">MOUSE_ENTER</a></li><li><a href="global.html#event:srgssr/recommendationDisplayed">srgssr/recommendationDisplayed</a></li><li><a href="global.html#event:srgssr/recommendationHit">srgssr/recommendationHit</a></li><li><a href="global.html#event:WEBKIT_CURRENT_PLAYBACK_TARGET_IS_WIRELESS_CHANGED">WEBKIT_CURRENT_PLAYBACK_TARGET_IS_WIRELESS_CHANGED</a></li><li><a href="global.html#event:WEBKIT_PLAYBACK_TARGET_AVAILABILITY_CHANGED">WEBKIT_PLAYBACK_TARGET_AVAILABILITY_CHANGED</a></li><li><a href="SRGLetterbox.html#event:events">events</a></li><li><a href="SRGLetterbox.html#event:playerEvents">playerEvents</a></li><li><a href="SRGLetterbox.html#event:srgEvents">srgEvents</a></li><li><a href="SRGLetterbox.html#event:videojsEvents">videojsEvents</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ABORT">ABORT</a></li><li><a href="global.html#ALMOST_STARTING">ALMOST_STARTING</a></li><li><a href="global.html#containQualities">containQualities</a></li><li><a href="global.html#DISPOSE">DISPOSE</a></li><li><a href="global.html#filterMainResourcesByQuality">filterMainResourcesByQuality</a></li><li><a href="global.html#findChapterByUrn">findChapterByUrn</a></li><li><a href="global.html#findDrmListByResource">findDrmListByResource</a></li><li><a href="global.html#findMainSegment">findMainSegment</a></li><li><a href="global.html#findResourceListByUrn">findResourceListByUrn</a></li><li><a href="global.html#getChapters">getChapters</a></li><li><a href="global.html#getFilteredExternalSubtitles">getFilteredExternalSubtitles</a></li><li><a href="global.html#getMainBlockReason">getMainBlockReason</a></li><li><a href="global.html#getMainChapter">getMainChapter</a></li><li><a href="global.html#getMainChapterImageUrl">getMainChapterImageUrl</a></li><li><a href="global.html#getMainResources">getMainResources</a></li><li><a href="global.html#getMainSegments">getMainSegments</a></li><li><a href="global.html#getMainValidFromDate">getMainValidFromDate</a></li><li><a href="global.html#getMergedAnalyticsData">getMergedAnalyticsData</a></li><li><a href="global.html#getMergedAnalyticsMetadata">getMergedAnalyticsMetadata</a></li><li><a href="global.html#getResourceList">getResourceList</a></li><li><a href="global.html#getSubdivisions">getSubdivisions</a></li><li><a href="global.html#isSourceHD">isSourceHD</a></li><li><a href="global.html#MAX_ITEMS">MAX_ITEMS</a></li><li><a href="global.html#MAX_ROWS">MAX_ROWS</a></li><li><a href="global.html#MIN_HEIGHT">MIN_HEIGHT</a></li><li><a href="global.html#MIN_WIDTH">MIN_WIDTH</a></li><li><a href="global.html#orderMainResourcesByQuality">orderMainResourcesByQuality</a></li><li><a href="global.html#orderMainResourcesByStreamType">orderMainResourcesByStreamType</a></li><li><a href="global.html#PERCENTAGE_MEDIA_CONSUMED">PERCENTAGE_MEDIA_CONSUMED</a></li><li><a href="global.html#PERIOD">PERIOD</a></li><li><a href="global.html#prefix">prefix</a></li><li><a href="global.html#SOON_VALID_PERIOD">SOON_VALID_PERIOD</a></li><li><a href="global.html#TOLERANCE">TOLERANCE</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Fri Feb 12 2021 09:53:42 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
